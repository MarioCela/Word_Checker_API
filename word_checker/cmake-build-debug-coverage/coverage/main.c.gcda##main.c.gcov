        -:    0:Source:/home/mario/Documents/GitHub/api-2022-final-project/word_checker/main.c
        -:    0:Graph:/home/mario/Documents/GitHub/api-2022-final-project/word_checker/cmake-build-debug-coverage/CMakeFiles/api_final_project.dir/main.c.gcno
        -:    0:Data:/home/mario/Documents/GitHub/api-2022-final-project/word_checker/cmake-build-debug-coverage/CMakeFiles/api_final_project.dir/main.c.gcda
        -:    0:Runs:1
        -:    1:#include <stdio.h>
        -:    2:#include <string.h>
        -:    3:#include <malloc.h>
        -:    4:
        -:    5://global variable
        -:    6://length of the words that will be inserted by input
        -:    7:int k;
        -:    8:
        -:    9:
        -:   10:
        -:   11:
        -:   12://structs
        -:   13://structure for the nodes where dictionary's words will be saved
        -:   14:struct Dictionary_Node {
        -:   15:    char *word;
        -:   16:    char color;
        -:   17:    struct Dictionary_Node *father;
        -:   18:    struct Dictionary_Node *next_left;
        -:   19:    struct Dictionary_Node *next_right;
        -:   20:};
        -:   21:
        -:   22://structure used as node in a BST to save the values of chars of strings to elaborate the resulting output
        -:   23://color is 0 if black, 1 if red
        -:   24:struct Char_Node {
        -:   25:    char key;
        -:   26:    char color;
        -:   27:    int occurrences_in_r;
        -:   28:    int in_the_correct_position_in_p;
        -:   29:    struct Char_Node *father;
        -:   30:    struct Char_Node *next_left;
        -:   31:    struct Char_Node *next_right;
        -:   32:};
        -:   33:
        -:   34:
        -:   35:
        -:   36:
        -:   37://leaves
        -:   38://dictionary node RB tree leaf
        -:   39:struct Dictionary_Node *dictionary_node_nil = NULL;
        -:   40:
        -:   41://char node RB tree leaf
        -:   42:struct Char_Node *char_node_nil = NULL;
        -:   43:
        -:   44://RB trees
        -:   45://head of the list of nodes of the dictionary
        -:   46:struct Dictionary_Node *dictionary_head = NULL;
        -:   47:
        -:   48://head of the list of words that could be the reference word, that is printed when +stampa_filtrate is inserted
        -:   49:struct Dictionary_Node *possible_words = NULL;
        -:   50:
        -:   51://RB-tree
        -:   52:struct Char_Node *word_characters = NULL;
        -:   53:
        -:   54:
        -:   55:
        -:   56:
        -:   57://functions signatures
        -:   58://function to initialize leaves node for dictionary tree
        -:   59:void initialize_dictionary_node_nil();
        -:   60:
        -:   61://function to initialize leaves node for char tree
        -:   62:void initialize_char_node_nil();
        -:   63:
        -:   64://function to read from input the value of the length of the words that will be inserted
        -:   65:void read_k();
        -:   66:
        -:   67://function to initialize the dictionary at the beginning of the program
        -:   68:void get_the_starting_dictionary();
        -:   69:
        -:   70://function to insert words to the dictionary
        -:   71:void insert_words_to_the_dictionary(char exit_string[]);
        -:   72:
        -:   73://function to create a new node of the RB tree where a word will be saved
        -:   74:short int manage_new_dictionary_node(char exit_string[]);
        -:   75:
        -:   76://function to create a new dictionary node
        -:   77:struct Dictionary_Node *create_new_dictionary_node(char *word);
        -:   78:
        -:   79://function to insert a new node to the dictionary RB tree
        -:   80:void insert_dictionary_node(struct Dictionary_Node *head, struct Dictionary_Node *new_node);
        -:   81:
        -:   82://function called after a dictionary node insertion to keep respected RB tree's properties
        -:   83:void dictionary_node_insert_fix(struct Dictionary_Node *node);
        -:   84:
        -:   85://function that implements left rotation for dictionary nodes
        -:   86:void dictionary_head_left_rotation(struct Dictionary_Node *x);
        -:   87:
        -:   88://function that implements right rotation for dictionary nodes
        -:   89:void dictionary_head_right_rotation(struct Dictionary_Node *y);
        -:   90:
        -:   91://function to print all the words saved in the dictionary RB tree
        -:   92:void print_dictionary(struct Dictionary_Node *node);
        -:   93:
        -:   94://function that manages a game
        -:   95:void new_game();
        -:   96:
        -:   97://function that initializes the RB tree of possible words
        -:   98:void initialize_possible_words_list();
        -:   99:
        -:  100://function that elaborates the resulting output string when user tries to guess the reference word
        -:  101:short int compute_res(char r[], char p[], char res[]);
        -:  102:
        -:  103://function that checks if a word inserted by the user to try to guess the reference word belongs to the dictionary or not
        -:  104:short int check_if_belongs_to_the_dictionary(char *word);
        -:  105:
        -:  106://function to search a node in the dictionary RB tree
        -:  107:short int search_a_dictionary_node(struct Dictionary_Node *node, char *word);
        -:  108:
        -:  109://function that implements quicksort algorithm
        -:  110:void quicksort(char *A, int lo, int hi);
        -:  111:
        -:  112://function that implements partition Hoare algorithm used by quicksort algorithm
        -:  113:int partition_Hoare(char *A, int lo, int hi);
        -:  114:
        -:  115://function to create a new char node
        -:  116:struct Char_Node *create_new_char_node(char c, int occ);
        -:  117:
        -:  118://function to insert a new node to the char RB tree
        -:  119:void insert_new_char_node(struct Char_Node *new_node);
        -:  120:
        -:  121://function called after a char node insertion to keep respected RB tree's properties
        -:  122:void char_node_insert_fix(struct Char_Node *node);
        -:  123:
        -:  124://function that implements left rotation for char nodes
        -:  125:void char_node_left_rotation(struct Char_Node *x);
        -:  126:
        -:  127://function that implements right rotation for char nodes
        -:  128:void char_node_right_rotation(struct Char_Node *y);
        -:  129:
        -:  130://function to increment the field in_the_correct_position_in_p in a char node, useful to correctly generate the resulting output
        -:  131:void increment_correct_position_count(char c);
        -:  132:
        -:  133://function to get the difference between occurrences_in_r and in_the_correct_position_in_p
        -:  134:int get_ni_minus_ci(char c);
        -:  135:
        -:  136://function to empty the RB tree made by char nodes
        -:  137:void remove_all_chars(struct Char_Node *node);
        -:  138:
        -:  139://function launched when game ends, all the nodes of the RB tree of possible words are removed
        -:  140:void remove_all_possible_words();
        -:  141:
        -:  142://function launched every time that a new game could start after another one finishes
        -:  143:short int start_new_game();
        -:  144:
        -:  145://function that defines the behavior depending on the user's input. Cases are to start a new game,
        -:  146://to close the program and to add new words to the dictionary
        -:  147:short int manage_input_new_game(short int *p);
        -:  148:
        -:  149://function to empty the RB tree containing the words that form the dictionary
        -:  150:void remove_all_dictionary_words(struct Dictionary_Node *node);
        -:  151:
        -:  152:
        -:  153:
        -:  154:
function main called 1 returned 100% blocks executed 100%
        1:  155:int main() {
        -:  156:    short int program_is_up;
        -:  157:
        -:  158:    //initializing the leaves for RB trees
        1:  159:    initialize_dictionary_node_nil();
        1:  159-block  0
call    0 returned 1
        1:  160:    initialize_char_node_nil();
call    0 returned 1
        -:  161:
        1:  162:    printf("Welcome to WordChecker game. Follow initial instructions and then start playing.\n"
call    0 returned 1
        -:  163:           "To start a new game insert +nuova_partita, followed by the word that has to be guessed,\n"
        -:  164:           "the number of attempts you have to guess it and then you can insert the attempts, \n"
        -:  165:           "each of them followed by the correspondent output\n\n");
        -:  166:
        -:  167:    //reading the lenght of the words
        1:  168:    read_k();
call    0 returned 1
        -:  169:    //getting the starting dictionary
        1:  170:    get_the_starting_dictionary();
call    0 returned 1
        -:  171:
        -:  172:    //printing the dictionary
        1:  173:    printf("The dictionary is:\n");
call    0 returned 1
        1:  174:    print_dictionary(dictionary_head);
call    0 returned 1
        -:  175:
        -:  176:    //launching a game and then, when the latter finishes, asking the user if he wants to close the program, to launch
        -:  177:    //a new game or to insert new words to the dictionary
        -:  178:    do {
        1:  179:        new_game();
        1:  179-block  0
call    0 returned 1
        1:  180:        program_is_up = start_new_game();
call    0 returned 1
        1:  181:    } while (program_is_up);
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:  182:
        -:  183:    //removing all the words contained in the dictionary RB tree
        1:  184:    remove_all_dictionary_words(dictionary_head);
        1:  184-block  0
call    0 returned 1
        -:  185:
        1:  186:    free(dictionary_node_nil);
        1:  187:    free(char_node_nil);
        -:  188:}
        -:  189:
        -:  190:/**
        -:  191: * The function initializes the leaf node for dictionary RB tree
        -:  192: */
function initialize_dictionary_node_nil called 1 returned 100% blocks executed 100%
        1:  193:void initialize_dictionary_node_nil() {
        1:  194:    dictionary_node_nil = malloc(sizeof(struct Dictionary_Node));
        -:  195:
        -:  196:    //all the leaves are black
        1:  197:    dictionary_node_nil->color = 'B';
        1:  198:    dictionary_node_nil->father = NULL;
        1:  199:    dictionary_node_nil->next_left = NULL;
        1:  200:    dictionary_node_nil->next_right = NULL;
        1:  201:}
        -:  202:
        -:  203:/**
        -:  204: * The function initializes the leaf node for chars RB tree
        -:  205: */
function initialize_char_node_nil called 6 returned 100% blocks executed 100%
        6:  206:void initialize_char_node_nil() {
        6:  207:    char_node_nil = malloc(sizeof(struct Char_Node));
        -:  208:
        -:  209:    //all the leaves are black
        6:  210:    char_node_nil->color = 'B';
        6:  211:    char_node_nil->father = NULL;
        6:  212:    char_node_nil->next_left = NULL;
        6:  213:    char_node_nil->next_right = NULL;
        6:  214:}
        -:  215:
        -:  216:/**
        -:  217: * The function read from the user the length of the words
        -:  218: */
function read_k called 1 returned 100% blocks executed 100%
        1:  219:void read_k() {
        -:  220:    int ins;
        -:  221:
        1:  222:    printf("Insert the length of the words.\n"
        1:  222-block  0
call    0 returned 1
        -:  223:           "Input: ");
        1:  224:    scanf("%d", &ins);
call    0 returned 1
        -:  225:
        1:  226:    k = ins + 1;
        1:  227:}
        -:  228:
        -:  229:/**
        -:  230: * The function is called when the program is run first and collects the words inserted by the user
        -:  231: */
function get_the_starting_dictionary called 1 returned 100% blocks executed 100%
        1:  232:void get_the_starting_dictionary() {
        1:  233:    insert_words_to_the_dictionary("+nuova_partita");
        1:  233-block  0
call    0 returned 1
        1:  234:}
        -:  235:
        -:  236:/**
        -:  237: * The function is called every time words have to be added to the dictionary
        -:  238: */
function insert_words_to_the_dictionary called 1 returned 100% blocks executed 100%
        1:  239:void insert_words_to_the_dictionary(char exit_string[]) {
        1:  240:    short int check = 1;
        -:  241:
        1:  242:    printf("\n");
        1:  242-block  0
call    0 returned 1
        -:  243:
        -:  244:    //goes on asking new words until ending loop input is inserted by user
        5:  245:    while (check) {
        5:  245-block  0
branch  0 taken 4
branch  1 taken 1 (fallthrough)
        4:  246:        check = manage_new_dictionary_node(exit_string);
        4:  246-block  0
call    0 returned 4
        -:  247:    }
        1:  248:}
        -:  249:
        -:  250:/**
        -:  251: * The function ask the user to insert a word or the ending loop string. If a word is inserted, it is created a node
        -:  252: * passed as parameter to the function that adds it to the dictionary RB tree
        -:  253: *
        -:  254: * @return 0 if the last input from user was +inserisci_fine, so there is no more need to ask for other words, 1 if not
        -:  255: */
function manage_new_dictionary_node called 4 returned 100% blocks executed 100%
        4:  256:short int manage_new_dictionary_node(char exit_string[]) {
        -:  257:    //getting the input
        4:  258:    char *insertion = malloc(sizeof(char) * k);
        4:  259:    printf("Insert a new word to the dictionary. Insert %s instead if you do not want to insert any other word: ",
        4:  259-block  0
call    0 returned 4
        -:  260:           exit_string);
        4:  261:    scanf("%s", insertion);
call    0 returned 4
        -:  262:
        -:  263:    //if it is not the ending loop string, the new node is inserted to the dictionary RB tree
        4:  264:    if (strcmp(insertion, exit_string) != 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  265:        insert_dictionary_node(dictionary_head, create_new_dictionary_node(insertion));
        3:  265-block  0
call    0 returned 3
call    1 returned 3
        3:  266:        return 1;
        -:  267:    } else {
        1:  268:        return 0;
        1:  268-block  0
        -:  269:    }
        -:  270:}
        -:  271:
        -:  272:/**
        -:  273: * The function creates a new dictionary node
        -:  274: *
        -:  275: * @param word is the string that will be saved into the node
        -:  276: * @return the node
        -:  277: */
function create_new_dictionary_node called 3 returned 100% blocks executed 100%
        3:  278:struct Dictionary_Node *create_new_dictionary_node(char *word) {
        3:  279:    struct Dictionary_Node *new_node = malloc(sizeof(struct Dictionary_Node));
        3:  280:    new_node->word = malloc(sizeof(char) * strlen(word));
        -:  281:
        3:  282:    new_node->word = word;
        -:  283:    //new node's color is initialized as red
        3:  284:    new_node->color = 'R';
        3:  285:    new_node->father = NULL;
        3:  286:    new_node->next_left = dictionary_node_nil;
        3:  287:    new_node->next_right = dictionary_node_nil;
        -:  288:
        3:  289:    return new_node;
        3:  289-block  0
        -:  290:}
        -:  291:
        -:  292:/**
        -:  293: * The function inserts a new node to the dictionary RB tree
        -:  294: *
        -:  295: * @param head is the head of the RB tree where the new node will be inserted
        -:  296: * @param new_node is the new node that will be inserted
        -:  297: */
function insert_dictionary_node called 3 returned 100% blocks executed 100%
        3:  298:void insert_dictionary_node(struct Dictionary_Node *head, struct Dictionary_Node *new_node) {
        3:  299:    struct Dictionary_Node *prev = NULL;
        3:  300:    struct Dictionary_Node *att = head;
        3:  301:    char left_or_right = 'R';
        -:  302:
        -:  303:    //if the tree has no elements, new_node is the new head
        3:  304:    if (dictionary_head == NULL) {
        3:  304-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  305:        dictionary_head = new_node;
        1:  306:        dictionary_head->color = 'B';
        1:  306-block  0
        -:  307:    } else {
        -:  308:        //if not, it is found the correct position and new_node is inserted to the tree
        5:  309:        while (att != dictionary_node_nil) {
        2:  309-block  0
        5:  309-block  1
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        8:  310:            for (int i = 0; i < k; ++i) {
        3:  310-block  0
        5:  310-block  1
        8:  310-block  2
branch  0 taken 5
branch  1 taken 3 (fallthrough)
        5:  311:                if (new_node->word[i] < att->word[i]) {
        5:  311-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2:  312:                    prev = att;
        2:  313:                    att = att->next_left;
        2:  314:                    left_or_right = 'L';
        2:  315:                    i = k;
        2:  315-block  0
        3:  316:                } else if (new_node->word[i] > att->word[i]) {
        3:  316-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  317:                    prev = att;
        1:  318:                    att = att->next_right;
        1:  319:                    left_or_right = 'R';
        1:  320:                    i = k;
        1:  320-block  0
        -:  321:                }
        -:  322:            }
        -:  323:        }
        -:  324:
        2:  325:        if (left_or_right == 'L') {
        2:  325-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  326:            prev->next_left = new_node;
        1:  327:            new_node->father = prev;
        1:  327-block  0
        -:  328:        } else {
        1:  329:            prev->next_right = new_node;
        1:  330:            new_node->father = prev;
        1:  330-block  0
        -:  331:        }
        -:  332:
        -:  333:        //after an insertion, RB tree's properties could have been violated: fixes could be needed
        2:  334:        dictionary_node_insert_fix(new_node);
        2:  334-block  0
call    0 returned 2
        -:  335:    }
        3:  336:}
        -:  337:
        -:  338:/**
        -:  339: * The function fixes a RB tree formed by dictionary nodes recoloring or rotating the nodes of the tree
        -:  340: * in order to keep respected RB tree's properties
        -:  341: *
        -:  342: * @param node is the node that has just been inserted into the tree
        -:  343: */
function dictionary_node_insert_fix called 2 returned 100% blocks executed 60%
        2:  344:void dictionary_node_insert_fix(struct Dictionary_Node *node) {
        3:  345:    while (node->father != NULL && node->father->color == 'R') {
        2:  345-block  0
        3:  345-block  1
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  345-block  2
branch  2 taken 1
branch  3 taken 2 (fallthrough)
        1:  346:        if (node->father == node->father->father->next_left) {
        1:  346-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  347:            struct Dictionary_Node *y = node->father->father->next_right;
        -:  348:
        1:  349:            if (y->color == 'R') {
        1:  349-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  350:                node->father->color = 'B';
    #####:  351:                y->color = 'B';
    #####:  352:                node->father->father->color = 'R';
    #####:  353:                node = node->father->father;
    %%%%%:  353-block  0
        -:  354:            }
        -:  355:            else {
        1:  356:                if (node == node->father->next_right) {
        1:  356-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  357:                    node = node->father;
        1:  358:                    dictionary_head_left_rotation(node);
        1:  358-block  0
call    0 returned 1
        -:  359:                }
        -:  360:
        1:  361:                node->father->color = 'B';
        1:  362:                node->father->father->color = 'R';
        1:  363:                dictionary_head_right_rotation(node->father->father);
        1:  363-block  0
call    0 returned 1
        -:  364:            }
        -:  365:
        -:  366:        } else {
    #####:  367:            struct Dictionary_Node *y = node->father->father->next_left;
        -:  368:
    #####:  369:            if (y->color == 'R') {
    %%%%%:  369-block  0
branch  0 never executed
branch  1 never executed
    #####:  370:                node->father->color = 'B';
    #####:  371:                y->color = 'B';
    #####:  372:                node->father->father->color = 'R';
    #####:  373:                node = node->father->father;
    %%%%%:  373-block  0
        -:  374:            }
        -:  375:            else {
    #####:  376:                if (node == node->father->next_left) {
    %%%%%:  376-block  0
branch  0 never executed
branch  1 never executed
    #####:  377:                    node = node->father;
    #####:  378:                    dictionary_head_right_rotation(node);
    %%%%%:  378-block  0
call    0 never executed
        -:  379:                }
        -:  380:
    #####:  381:                node->father->color = 'B';
    #####:  382:                node->father->father->color = 'R';
    #####:  383:                dictionary_head_left_rotation(node->father->father);
    %%%%%:  383-block  0
call    0 never executed
        -:  384:            }
        -:  385:        }
        -:  386:    }
        -:  387:
        2:  388:    dictionary_head->color = 'B';
        2:  389:}
        -:  390:
        -:  391:/**
        -:  392: * The function implements left rotation for dictionary nodes
        -:  393: *
        -:  394: * @param x and x->next_right are the nodes that will be left rotated
        -:  395: */
function dictionary_head_left_rotation called 1 returned 100% blocks executed 62%
        1:  396:void dictionary_head_left_rotation(struct Dictionary_Node *x) {
        1:  397:    struct Dictionary_Node *y = x->next_right;
        -:  398:
        1:  399:    if (y->next_left != dictionary_node_nil) {
        1:  399-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  400:        x->next_right = y->next_left;
    #####:  401:        y->next_left->father = x;
    %%%%%:  401-block  0
        -:  402:    }
        -:  403:
        1:  404:    if (x->father == NULL) {
        1:  404-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  405:        dictionary_head = y;
    #####:  406:        y->father = NULL;
    %%%%%:  406-block  0
        1:  407:    } else if (x == x->father->next_left) {
        1:  407-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  408:        x->father->next_left = y;
        1:  409:        y->father = x->father;
        1:  409-block  0
        -:  410:    } else {
    #####:  411:        x->father->next_right = y;
    #####:  412:        y->father = x->father;
    %%%%%:  412-block  0
        -:  413:    }
        -:  414:
        1:  415:    x->next_right = y->next_left;
        1:  416:    x->father = y;
        1:  417:    y->next_left = x;
        1:  418:}
        -:  419:
        -:  420:/**
        -:  421: * The function implements right rotation for dictionary nodes
        -:  422: *
        -:  423: * @param y and y->next_left are the nodes that will be right rotated
        -:  424: */
function dictionary_head_right_rotation called 1 returned 100% blocks executed 50%
        1:  425:void dictionary_head_right_rotation(struct Dictionary_Node *y) {
        1:  426:    struct Dictionary_Node *x = y->next_left;
        -:  427:
        1:  428:    if (x->next_right != dictionary_node_nil) {
        1:  428-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  429:        y->next_left = x->next_right;
    #####:  430:        x->next_right->father = y;
    %%%%%:  430-block  0
        -:  431:    }
        -:  432:
        1:  433:    if (y->father == NULL) {
        1:  433-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  434:        dictionary_head = x;
        1:  435:        x->father = NULL;
        1:  435-block  0
    #####:  436:    } else if (y == y->father->next_right) {
    %%%%%:  436-block  0
branch  0 never executed
branch  1 never executed
    #####:  437:        y->father->next_right = x;
    #####:  438:        x->father = y->father;
    %%%%%:  438-block  0
        -:  439:    } else {
    #####:  440:        y->father->next_left = x;
    #####:  441:        x->father = y->father;
    %%%%%:  441-block  0
        -:  442:    }
        -:  443:
        1:  444:    y->next_left = x->next_right;
        1:  445:    y->father = x;
        1:  446:    x->next_right = y;
        1:  447:}
        -:  448:
        -:  449:/**
        -:  450: * The function prints in order the nodes of the RB tree made by dictionary nodes
        -:  451: */
function print_dictionary called 3 returned 100% blocks executed 100%
        3:  452:void print_dictionary(struct Dictionary_Node *node) {
        3:  453:    if (node->next_left != dictionary_node_nil) {
        3:  453-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  454:        print_dictionary(node->next_left);
        1:  454-block  0
call    0 returned 1
        -:  455:    }
        3:  456:    printf("%s\n", node->word);
        3:  456-block  0
call    0 returned 3
        3:  457:    if (node->next_right != dictionary_node_nil) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  458:        print_dictionary(node->next_right);
        1:  458-block  0
call    0 returned 1
        -:  459:    }
        3:  460:}
        -:  461:
        -:  462:/**
        -:  463: * TODO +stampa_filtrate
        -:  464: *
        -:  465: * The function is launched when a new game starts.
        -:  466: * They are asked: the reference word, the number of attempts to try to guess the reference word, and the effective attempts
        -:  467: */
function new_game called 1 returned 100% blocks executed 100%
        1:  468:void new_game() {
        1:  469:    char *ref = malloc(k);
        -:  470:
        -:  471:    //asking for the reference word
        1:  472:    printf("\nInsert the reference word, the one that has to be guessed: ");
        1:  472-block  0
call    0 returned 1
        1:  473:    scanf("%s", ref);
call    0 returned 1
        -:  474:
        -:  475:    //initializing the RB tree containing the words that will be printed after +stampa_filtrate input
        1:  476:    initialize_possible_words_list();
call    0 returned 1
        -:  477:
        -:  478:    int attempts;
        -:  479:
        -:  480:    //asking for the number of attempts
        1:  481:    printf("\nInsert the number of attempts: ");
call    0 returned 1
        1:  482:    scanf("%d", &attempts);
call    0 returned 1
        -:  483:
        1:  484:    printf("\n");
call    0 returned 1
        -:  485:
        -:  486:    //asking for the words to guess the reference word
        6:  487:    for (int i = 0; i < attempts; ++i) {
        6:  487-block  0
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        5:  488:        char *word = malloc(k);
        5:  489:        char *result = malloc(k);
        -:  490:
        5:  491:        printf("Try to guess the word (tentative n. %d): ", i + 1);
        5:  491-block  0
call    0 returned 5
        5:  492:        scanf("%s", word);
call    0 returned 5
        -:  493:
        5:  494:        short int r = compute_res(ref, word, result);
call    0 returned 5
        -:  495:
        -:  496:        //printing the output depending on the result: word belongs to the dictionary or not, the words has been guessed or not
        5:  497:        if (r == 0) {
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2:  498:            printf("Output: %s\n\n", result);
        2:  498-block  0
call    0 returned 2
        3:  499:        } else if (r == 1) {
        3:  499-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  500:            printf("Output: ok\n\n");
        1:  500-block  0
call    0 returned 1
        1:  501:            i = attempts;
        -:  502:        } else {
        2:  503:            printf("Output: not exist\n\n");
        2:  503-block  0
call    0 returned 2
        -:  504:        }
        -:  505:
        5:  506:        free(result);
        5:  507:        free(word);
        -:  508:
        -:  509:        //char_node_nil has to be reinitialized at every iteration because of the free function
        5:  510:        initialize_char_node_nil();
        5:  510-block  0
call    0 returned 5
        -:  511:    }
        -:  512:
        1:  513:    free(ref);
        -:  514:
        -:  515:    //removing all the RB tree nodes containing the words that would be printed after +stampa_filtrate input
        1:  516:    remove_all_possible_words();
        1:  516-block  0
call    0 returned 1
        1:  517:}
        -:  518:
        -:  519:/**
        -:  520: * TODO +stampa_filtrate
        -:  521: */
function initialize_possible_words_list called 1 returned 100% blocks executed 100%
        1:  522:void initialize_possible_words_list() {
        -:  523:
        1:  524:}
        -:  525:
        -:  526:/**
        -:  527: * TODO +stampa_filtrate
        -:  528: *
        -:  529: * The function generates the output string depending on the string r and p received as params
        -:  530: *
        -:  531: * @param r is the reference word that has to be guessed
        -:  532: * @param p is the word that tries to guess r
        -:  533: * @param res is the resulting string
        -:  534: * @return 1 if the word has been guessed, 0 if not, 2 if the word inserted is not in the dictionary
        -:  535: */
function compute_res called 5 returned 100% blocks executed 96%
        5:  536:short int compute_res(char *r, char *p, char res[]) {
        5:  537:    if (!check_if_belongs_to_the_dictionary(p)) {
        5:  537-block  0
call    0 returned 5
branch  1 taken 2 (fallthrough)
branch  2 taken 3
        2:  538:        return 2;
        2:  538-block  0
        3:  539:    } else {
        -:  540:        int i;
        3:  541:        short int result = 1;
        -:  542:
        -:  543:        //r and p are ordered using quicksort algorithm
        3:  544:        char r_ordered[k];
        3:  545:        char p_ordered[k];
        3:  546:        strcpy(r_ordered, r);
        3:  547:        strcpy(p_ordered, p);
        -:  548:
        3:  549:        quicksort(r_ordered, 0, k - 2);
        3:  549-block  0
call    0 returned 3
        3:  550:        quicksort(p_ordered, 0, k - 2);
call    0 returned 3
        -:  551:
        3:  552:        int r_index = 0;
        -:  553:        int p_index;
        -:  554:
        -:  555:        int occur_in_r;
        -:  556:
        -:  557:        //looping on the chars of p_ordered
       18:  558:        for (p_index = 0; p_index < k - 1; ++p_index) {
       15:  558-block  0
       18:  558-block  1
branch  0 taken 15
branch  1 taken 3 (fallthrough)
        -:  559:
        -:  560:            //count of the occurrences in r of the char read in p_ordered[p_index]
       15:  561:            occur_in_r = 0;
        -:  562:
        -:  563:            //used when it is tried to find p_ordered[i] in r, but it is not contained in it,
        -:  564:            //so it is needed to return to the old index
       15:  565:            int old_r_index = r_index;
        -:  566:
        -:  567:            //if in the ordered string of p there are adjacent chars with the same content, the following ones are ignored
       15:  568:            if (p_index == 0 || p_ordered[p_index] != p_ordered[p_index - 1]) {
       15:  568-block  0
branch  0 taken 12 (fallthrough)
branch  1 taken 3
       12:  568-block  1
branch  2 taken 11 (fallthrough)
branch  3 taken 1
        -:  569:
        -:  570:                //r_index is incremented until we find the same char it is being watched in p_ordered[p_index],
        -:  571:                //or until the string finishes
       29:  572:                for (; r_ordered[r_index] != p_ordered[p_index] && r_index < k - 1; ++r_index) {
       14:  572-block  0
       15:  572-block  1
       29:  572-block  2
branch  0 taken 19 (fallthrough)
branch  1 taken 10
       19:  572-block  3
branch  2 taken 15
branch  3 taken 4 (fallthrough)
        -:  573:
        -:  574:                }
        -:  575:
        -:  576:                //if it has been reached the end of the string, it means that there is no occurrences in r of p_ordered[p_index]
        -:  577:                //r_index is set again to its old value, because there could be other char to be analyzed,
        -:  578:                //and the p_ordered[p_index] is inserted into the RB tree
       14:  579:                if (r_ordered[r_index] != p_ordered[p_index]) {
       14:  579-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 10
        4:  580:                    r_index = old_r_index;
        4:  580-block  0
        -:  581:                } else {
        -:  582:                    //otherwise, it is counted the number of occurrences
       20:  583:                    for (; r_ordered[r_index] == p_ordered[p_index] && r_index < k - 1; ++r_index) {
       10:  583-block  0
       20:  583-block  1
branch  0 taken 10 (fallthrough)
branch  1 taken 10
       10:  583-block  2
branch  2 taken 10
branch  3 taken 0 (fallthrough)
       10:  584:                        ++occur_in_r;
       10:  584-block  0
        -:  585:                    }
        -:  586:                }
        -:  587:
        -:  588:
        -:  589:                //p_ordered[p_index] is inserted into the RB tree of char nodes
       14:  590:                insert_new_char_node(create_new_char_node(p_ordered[p_index], occur_in_r));
       14:  590-block  0
call    0 returned 14
call    1 returned 14
        -:  591:            }
        -:  592:        }
        -:  593:
        -:  594:        //all the initial string is read in order to set + when r[i] and p[i] match
       18:  595:        for (i = 0; i < k - 1; ++i) {
        3:  595-block  0
       15:  595-block  1
       18:  595-block  2
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       15:  596:            if (r[i] == p[i]) {
       15:  596-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 9
        6:  597:                res[i] = '+';
        6:  598:                increment_correct_position_count(p[i]);
        6:  598-block  0
call    0 returned 6
        -:  599:            } else {
        9:  600:                res[i] = '*';
        9:  601:                result = 0;
        9:  601-block  0
        -:  602:            }
        -:  603:        }
        -:  604:
        -:  605:        //positions where has not been set a + are managed
       18:  606:        for (i = 0; i < k - 1; ++i) {
        3:  606-block  0
       15:  606-block  1
       18:  606-block  2
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       15:  607:            if (res[i] == '*') {
       15:  607-block  0
branch  0 taken 9 (fallthrough)
branch  1 taken 6
        9:  608:                int count = 0;
        -:  609:                //starting for current position - 1, it is counted the number of char equals to p[i], useful to find out
        -:  610:                //if a / or a | has to be set
       26:  611:                for (int j = i - 1; j >= 0; --j) {
        9:  611-block  0
       17:  611-block  1
       26:  611-block  2
branch  0 taken 17
branch  1 taken 9 (fallthrough)
      17*:  612:                    if (p[j] == p[i] && p[j] != r[j]) {
       17:  612-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 17
    %%%%%:  612-block  1
branch  2 never executed
branch  3 never executed
    #####:  613:                        ++count;
    %%%%%:  613-block  0
        -:  614:                    }
        -:  615:                }
        -:  616:
        9:  617:                int diff = get_ni_minus_ci(p[i]);
        9:  617-block  0
call    0 returned 9
        -:  618:
        -:  619:                //correct output is set at position i
        9:  620:                if (count >= diff) {
branch  0 taken 5 (fallthrough)
branch  1 taken 4
        5:  621:                    res[i] = '/';
        5:  621-block  0
        -:  622:                } else {
        4:  623:                    res[i] = '|';
        4:  623-block  0
        -:  624:                }
        -:  625:            }
        -:  626:        }
        -:  627:
        -:  628:        //the RB tree containing char nodes is emptied
        3:  629:        remove_all_chars(word_characters);
        3:  629-block  0
call    0 returned 3
        3:  630:        word_characters = NULL;
        -:  631:
        3:  632:        res[i] = '\0';
        -:  633:
        3:  634:        return result;
        -:  635:    }
        -:  636:}
        -:  637:
        -:  638:/**
        -:  639: * The function checks if the param word belongs to the dictionary RB tree
        -:  640: *
        -:  641: * @param word is the word inserted by user in input to try to guess the reference word
        -:  642: * @return 1 if the word belongs to the dictionary, 0 if not
        -:  643: */
function check_if_belongs_to_the_dictionary called 5 returned 100% blocks executed 100%
        5:  644:short int check_if_belongs_to_the_dictionary(char *word) {
        5:  645:    return search_a_dictionary_node(dictionary_head, word);
        5:  645-block  0
call    0 returned 5
        -:  646:}
        -:  647:
        -:  648:/**
        -:  649: * The function searches a word in the dictionary and tells to the caller if it is in it or not.
        -:  650: * It is a recursive function, calling itself to the next left and right nodes
        -:  651: *
        -:  652: * @param node is the actual node is being analyzed to see if the word is saved here or not
        -:  653: * @param word is the work is being looked for
        -:  654: * @return 1 if the word is in the subtree, 0 if not
        -:  655: */
function search_a_dictionary_node called 22 returned 100% blocks executed 100%
       22:  656:short int search_a_dictionary_node(struct Dictionary_Node *node, char *word) {
       22:  657:    if (node != dictionary_node_nil) {
       22:  657-block  0
branch  0 taken 12 (fallthrough)
branch  1 taken 10
       12:  658:        if (strcmp(word, node->word) == 0) {
       12:  658-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 9
        3:  659:            return 1;
        3:  659-block  0
        -:  660:        } else {
        9:  661:            if (search_a_dictionary_node(node->next_left, word) == 1) {
        9:  661-block  0
call    0 returned 9
branch  1 taken 1 (fallthrough)
branch  2 taken 8
        1:  662:                return 1;
        1:  662-block  0
        -:  663:            }
        8:  664:            if (search_a_dictionary_node(node->next_right, word) == 1) {
        8:  664-block  0
call    0 returned 8
branch  1 taken 1 (fallthrough)
branch  2 taken 7
        1:  665:                return 1;
        1:  665-block  0
        -:  666:            }
        -:  667:        }
        -:  668:    }
        -:  669:
       17:  670:    return 0;
       17:  670-block  0
        -:  671:}
        -:  672:
        -:  673:/**
        -:  674: * The function implements quicksort algorithm
        -:  675: *
        -:  676: * @param A is the string that has to be ordered
        -:  677: * @param lo is low index
        -:  678: * @param hi is high index
        -:  679: */
function quicksort called 34 returned 100% blocks executed 100%
       34:  680:void quicksort(char *A, int lo, int hi) {
       34:  681:    if (lo < hi) {
       34:  681-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 20
       14:  682:        int p = partition_Hoare(A, lo, hi);
       14:  682-block  0
call    0 returned 14
       14:  683:        quicksort(A, lo, p - 1);
call    0 returned 14
       14:  684:        quicksort(A, p + 1, hi);
call    0 returned 14
        -:  685:    }
       34:  686:}
        -:  687:
        -:  688:/**
        -:  689: * The function implements the Partition Hoare algorithm used by quicksort algorithm
        -:  690: *
        -:  691: * @param A is the string that has to be ordered
        -:  692: * @param lo is low index
        -:  693: * @param hi is high index
        -:  694: */
function partition_Hoare called 14 returned 100% blocks executed 100%
       14:  695:int partition_Hoare(char *A, int lo, int hi) {
       14:  696:    char pivot = A[hi];
       14:  697:    int i = lo - 1;
        -:  698:
       51:  699:    for (int j = lo; j <= hi - 1; ++j) {
       14:  699-block  0
       37:  699-block  1
       51:  699-block  2
branch  0 taken 37
branch  1 taken 14 (fallthrough)
       37:  700:        if (A[j] < pivot) {
       37:  700-block  0
branch  0 taken 23 (fallthrough)
branch  1 taken 14
       23:  701:            i++;
        -:  702:
       23:  703:            char tmp = A[i];
       23:  704:            A[i] = A[j];
       23:  705:            A[j] = tmp;
       23:  705-block  0
        -:  706:        }
        -:  707:    }
        -:  708:
       14:  709:    char tmp = A[i + 1];
       14:  710:    A[i + 1] = A[hi];
       14:  711:    A[hi] = tmp;
        -:  712:
       14:  713:    return i + 1;
       14:  713-block  0
        -:  714:}
        -:  715:
        -:  716:/**
        -:  717: * The function creates a new char node
        -:  718: *
        -:  719: * @param c is the key value of the node, the char that has to be saved
        -:  720: * @return the node that has been allocated and initialized
        -:  721: */
function create_new_char_node called 14 returned 100% blocks executed 100%
       14:  722:struct Char_Node *create_new_char_node(char c, int occ) {
       14:  723:    struct Char_Node *new_node = malloc(sizeof(struct Char_Node));
       14:  724:    new_node->key = c;
        -:  725:    //a new node is always initialized as a red node
       14:  726:    new_node->color = 'R';
       14:  727:    new_node->occurrences_in_r = occ;
       14:  728:    new_node->in_the_correct_position_in_p = 0;
       14:  729:    new_node->father = NULL;
        -:  730:    //the leaves are NIL
       14:  731:    new_node->next_left = char_node_nil;
       14:  732:    new_node->next_right = char_node_nil;
       14:  733:}
        -:  734:
        -:  735:/**
        -:  736: * The function inserts a new char node into the RB tree of chars
        -:  737: *
        -:  738: * @param new_node is the new node that has to be inserted
        -:  739: */
function insert_new_char_node called 14 returned 100% blocks executed 83%
       14:  740:void insert_new_char_node(struct Char_Node *new_node) {
       14:  741:    struct Char_Node *prev = NULL;
       14:  742:    struct Char_Node *att = word_characters;
        -:  743:
        -:  744:    //if the tree has no elements, new_node is the new head
       14:  745:    if (word_characters == NULL) {
       14:  745-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 11
        3:  746:        word_characters = new_node;
        3:  747:        word_characters->color = 'B';
        3:  747-block  0
        -:  748:    } else {
        -:  749:        //if not, it is found the correct position and new_node is inserted to the tree
       32:  750:        while (att != char_node_nil) {
       11:  750-block  0
       32:  750-block  1
branch  0 taken 21
branch  1 taken 11 (fallthrough)
       21:  751:            if (new_node->key < att->key) {
       21:  751-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 21
    #####:  752:                prev = att;
    #####:  753:                att = att->next_left;
    %%%%%:  753-block  0
        -:  754:            } else {
       21:  755:                prev = att;
       21:  756:                att = att->next_right;
       21:  756-block  0
        -:  757:            }
        -:  758:        }
        -:  759:
       11:  760:        if (new_node->key < prev->key) {
       11:  760-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:  761:            prev->next_left = new_node;
    #####:  762:            new_node->father = prev;
    %%%%%:  762-block  0
        -:  763:        } else {
       11:  764:            prev->next_right = new_node;
       11:  765:            new_node->father = prev;
       11:  765-block  0
        -:  766:        }
        -:  767:
        -:  768:        //after an insertion, RB tree's properties could have been violated: fixes could be needed
       11:  769:        char_node_insert_fix(new_node);
       11:  769-block  0
call    0 returned 11
        -:  770:    }
       14:  771:}
        -:  772:
        -:  773:/**
        -:  774: * The function is called when a new node is inserted but that could violate RB tree properties,
        -:  775: * so fixes could be needed
        -:  776: *
        -:  777: * @param node is the new inserted node that could activate fix algorithms
        -:  778: */
function char_node_insert_fix called 11 returned 100% blocks executed 60%
       11:  779:void char_node_insert_fix(struct Char_Node *node) {
       19:  780:    while (node->father != NULL && node->father->color == 'R') {
       11:  780-block  0
       19:  780-block  1
branch  0 taken 16 (fallthrough)
branch  1 taken 3
       16:  780-block  2
branch  2 taken 8
branch  3 taken 8 (fallthrough)
        8:  781:        if (node->father == node->father->father->next_left) {
        8:  781-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####:  782:            struct Char_Node *y = node->father->father->next_right;
        -:  783:
    #####:  784:            if (y->color == 'R') {
    %%%%%:  784-block  0
branch  0 never executed
branch  1 never executed
    #####:  785:                node->father->color = 'B';
    #####:  786:                y->color = 'B';
    #####:  787:                node->father->father->color = 'R';
    #####:  788:                node = node->father->father;
    %%%%%:  788-block  0
        -:  789:            }
        -:  790:            else {
    #####:  791:                if (node == node->father->next_right) {
    %%%%%:  791-block  0
branch  0 never executed
branch  1 never executed
    #####:  792:                    node = node->father;
    #####:  793:                    char_node_left_rotation(node);
    %%%%%:  793-block  0
call    0 never executed
        -:  794:                }
        -:  795:
    #####:  796:                node->father->color = 'B';
    #####:  797:                node->father->father->color = 'R';
    #####:  798:                char_node_right_rotation(node->father->father);
    %%%%%:  798-block  0
call    0 never executed
        -:  799:            }
        -:  800:
        -:  801:        } else {
        8:  802:            struct Char_Node *y = node->father->father->next_left;
        -:  803:
        8:  804:            if (y->color == 'R') {
        8:  804-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 5
        3:  805:                node->father->color = 'B';
        3:  806:                y->color = 'B';
        3:  807:                node->father->father->color = 'R';
        3:  808:                node = node->father->father;
        3:  808-block  0
        -:  809:            }
        -:  810:            else {
        5:  811:                if (node == node->father->next_left) {
        5:  811-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  812:                    node = node->father;
    #####:  813:                    char_node_right_rotation(node);
    %%%%%:  813-block  0
call    0 never executed
        -:  814:                }
        -:  815:
        5:  816:                node->father->color = 'B';
        5:  817:                node->father->father->color = 'R';
        5:  818:                char_node_left_rotation(node->father->father);
        5:  818-block  0
call    0 returned 5
        -:  819:            }
        -:  820:        }
        -:  821:    }
        -:  822:
       11:  823:    word_characters->color = 'B';
       11:  824:}
        -:  825:
        -:  826:/**
        -:  827: * The function implements the left rotation algorithm in a RB tree
        -:  828: *
        -:  829: * @param x and its successor x->next_right are the node that will be left rotated
        -:  830: */
function char_node_left_rotation called 5 returned 100% blocks executed 75%
        5:  831:void char_node_left_rotation(struct Char_Node *x) {
        5:  832:    struct Char_Node *y = x->next_right;
        -:  833:
        5:  834:    if (y->next_left != char_node_nil) {
        5:  834-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  835:        x->next_right = y->next_left;
    #####:  836:        y->next_left->father = x;
    %%%%%:  836-block  0
        -:  837:    }
        -:  838:
        5:  839:    if (x->father == NULL) {
        5:  839-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:  840:        word_characters = y;
        3:  841:        y->father = NULL;
        3:  841-block  0
        2:  842:    } else if (x == x->father->next_left) {
        2:  842-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  843:        x->father->next_left = y;
    #####:  844:        y->father = x->father;
    %%%%%:  844-block  0
        -:  845:    } else {
        2:  846:        x->father->next_right = y;
        2:  847:        y->father = x->father;
        2:  847-block  0
        -:  848:    }
        -:  849:
        5:  850:    x->next_right = y->next_left;
        5:  851:    x->father = y;
        5:  852:    y->next_left = x;
        5:  853:}
        -:  854:
        -:  855:/**
        -:  856: * The function implements the right rotation algorithm in a RB tree
        -:  857: *
        -:  858: * @param y and its successor y->next_left are the node that will be right rotated
        -:  859: */
function char_node_right_rotation called 0 returned 0% blocks executed 0%
    #####:  860:void char_node_right_rotation(struct Char_Node *y) {
    #####:  861:    struct Char_Node *x = y->next_left;
        -:  862:
    #####:  863:    if (x->next_right != char_node_nil) {
    %%%%%:  863-block  0
branch  0 never executed
branch  1 never executed
    #####:  864:        y->next_left = x->next_right;
    #####:  865:        x->next_right->father = y;
    %%%%%:  865-block  0
        -:  866:    }
        -:  867:
    #####:  868:    if (y->father == NULL) {
    %%%%%:  868-block  0
branch  0 never executed
branch  1 never executed
    #####:  869:        word_characters = x;
    #####:  870:        x->father = NULL;
    %%%%%:  870-block  0
    #####:  871:    } else if (y == y->father->next_right) {
    %%%%%:  871-block  0
branch  0 never executed
branch  1 never executed
    #####:  872:        y->father->next_right = x;
    #####:  873:        x->father = y->father;
    %%%%%:  873-block  0
        -:  874:    } else {
    #####:  875:        y->father->next_left = x;
    #####:  876:        x->father = y->father;
    %%%%%:  876-block  0
        -:  877:    }
        -:  878:
    #####:  879:    y->next_left = x->next_right;
    #####:  880:    y->father = x;
    #####:  881:    x->next_right = y;
    #####:  882:}
        -:  883:
        -:  884:/**
        -:  885: * The function increment by 1 the value of int field in_the_correct_position_in_p of a char node.
        -:  886: * This value is used to generate the resulting output when the user tries to guess the word
        -:  887: *
        -:  888: * @param c is the char, the key value of the node
        -:  889: */
function increment_correct_position_count called 6 returned 100% blocks executed 100%
        6:  890:void increment_correct_position_count(char c) {
        6:  891:    struct Char_Node *tmp = word_characters;
        -:  892:
       19:  893:    while (tmp != char_node_nil) {
        6:  893-block  0
       19:  893-block  1
branch  0 taken 13
branch  1 taken 6 (fallthrough)
       13:  894:        if (tmp->key == c) {
       13:  894-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 7
        6:  895:            ++tmp->in_the_correct_position_in_p;
        6:  896:            tmp = char_node_nil;
        6:  896-block  0
        -:  897:        } else {
        7:  898:            if (c < tmp->key) {
        7:  898-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 4
        3:  899:                tmp = tmp->next_left;
        3:  899-block  0
        -:  900:            } else {
        4:  901:                tmp = tmp->next_right;
        4:  901-block  0
        -:  902:            }
        -:  903:        }
        -:  904:    }
        6:  905:}
        -:  906:
        -:  907:/**
        -:  908: * The function is used to get the difference between the fields indicated in the return section.
        -:  909: * The value is used to generate the resulting output when the user tries to guess the word
        -:  910: *
        -:  911: * @param c is the char, the key value of the node
        -:  912: * @return the difference between occurrences_in_r and in_the_correct_position_in_p
        -:  913: */
function get_ni_minus_ci called 9 returned 100% blocks executed 100%
        9:  914:int get_ni_minus_ci(char c) {
        -:  915:    int ni;
        -:  916:    int ci;
        9:  917:    struct Char_Node *tmp = word_characters;
        -:  918:
       28:  919:    while (tmp != char_node_nil) {
        9:  919-block  0
       28:  919-block  1
branch  0 taken 19
branch  1 taken 9 (fallthrough)
       19:  920:        if (c == tmp->key) {
       19:  920-block  0
branch  0 taken 9 (fallthrough)
branch  1 taken 10
        9:  921:            ni = tmp->occurrences_in_r;
        9:  922:            ci = tmp->in_the_correct_position_in_p;
        9:  923:            tmp = char_node_nil;
        9:  923-block  0
       10:  924:        } else if (c < tmp->key) {
       10:  924-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 7
        3:  925:            tmp = tmp->next_left;
        3:  925-block  0
        -:  926:        } else {
        7:  927:            tmp = tmp->next_right;
        7:  927-block  0
        -:  928:        }
        -:  929:    }
        -:  930:
        9:  931:    return (ni - ci);
        9:  931-block  0
        -:  932:}
        -:  933:
        -:  934:/**
        -:  935: * The function deallocates all the memory allocated for char nodes saved into the RB tree
        -:  936: *
        -:  937: * @param node is the node from which the function will be called to its left and right subtrees and that then will be freed
        -:  938: */
function remove_all_chars called 14 returned 100% blocks executed 100%
       14:  939:void remove_all_chars(struct Char_Node *node) {
       14:  940:    if (node->next_left != char_node_nil) {
       14:  940-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 9
        5:  941:        remove_all_chars(node->next_left);
        5:  941-block  0
call    0 returned 5
        -:  942:    }
       14:  943:    if (node->next_right != char_node_nil) {
       14:  943-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 8
        6:  944:        remove_all_chars(node->next_right);
        6:  944-block  0
call    0 returned 6
        -:  945:    }
       14:  946:    free(node);
       14:  947:}
        -:  948:
        -:  949:/**
        -:  950: * TODO +stampa_filtrate
        -:  951: */
function remove_all_possible_words called 1 returned 100% blocks executed 100%
        1:  952:void remove_all_possible_words() {
        -:  953:
        1:  954:}
        -:  955:
        -:  956:/**
        -:  957: * The function is called when previous game ended and the program needs to know if a new one has to be started or not
        -:  958: * @return 1 if a new game has to be started, 0 if not
        -:  959: */
function start_new_game called 1 returned 100% blocks executed 100%
        1:  960:short int start_new_game() {
        1:  961:    short int continue_asking_input = 1;
        1:  962:    short int game_goes_on = 1;
        1:  963:    short int *ptr = &game_goes_on;
        -:  964:
        2:  965:    while (continue_asking_input) {
        1:  965-block  0
        2:  965-block  1
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1:  966:        continue_asking_input = manage_input_new_game(ptr);
        1:  966-block  0
call    0 returned 1
        -:  967:    }
        -:  968:
        1:  969:    return game_goes_on;
        1:  969-block  0
        -:  970:}
        -:  971:
        -:  972:/**
        -:  973: * The function manages the input by the player, that can choose to start a new game, to close the program, or to
        -:  974: * insert new words to the dictionary
        -:  975: *
        -:  976: * @param p is a pointer to game_goes_on variable in start_new_game method
        -:  977: * @return 1 if this method has to be called again, 0 if not
        -:  978: */
function manage_input_new_game called 1 returned 100% blocks executed 55%
        1:  979:short int manage_input_new_game(short int *p) {
        1:  980:    char *ins = malloc(18);
        -:  981:
        1:  982:    printf("\nStart a new game inserting +nuova_partita;\n"
        1:  982-block  0
call    0 returned 1
        -:  983:           "Close the program inserting +game_over;\n"
        -:  984:           "Add new words to the dictionary inserting +inserisci_inizio.\n"
        -:  985:           "Input: ");
        1:  986:    scanf("%s", ins);
call    0 returned 1
        -:  987:
        1:  988:    if (strcmp(ins, "+nuova_partita") == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  989:        *p = 1;
    #####:  990:        free(ins);
    #####:  991:        return 0;
    %%%%%:  991-block  0
        1:  992:    } else if (strcmp(ins, "+game_over") == 0) {
        1:  992-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  993:        *p = 0;
        1:  994:        free(ins);
        1:  995:        return 0;
        1:  995-block  0
    #####:  996:    } else if (strcmp(ins, "+inserisci_inizio") == 0) {
    %%%%%:  996-block  0
branch  0 never executed
branch  1 never executed
    #####:  997:        insert_words_to_the_dictionary("+inserisci_fine");
    %%%%%:  997-block  0
call    0 never executed
    #####:  998:        free(ins);
    #####:  999:        return 1;
        -: 1000:    }
    #####: 1001:}
    %%%%%: 1001-block  0
        -: 1002:
        -: 1003:/**
        -: 1004: * The function deallocates all the memory allocated for dictionary nodes saved into the RB tree
        -: 1005: *
        -: 1006: * @param node is the node from which the function will be called to its left and right subtrees and that then will be freed
        -: 1007: */
function remove_all_dictionary_words called 3 returned 100% blocks executed 100%
        3: 1008:void remove_all_dictionary_words(struct Dictionary_Node *node) {
        3: 1009:    if (node->next_left != dictionary_node_nil) {
        3: 1009-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 1010:        remove_all_dictionary_words(node->next_left);
        1: 1010-block  0
call    0 returned 1
        -: 1011:    }
        3: 1012:    if (node->next_right != dictionary_node_nil) {
        3: 1012-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 1013:        remove_all_dictionary_words(node->next_right);
        1: 1013-block  0
call    0 returned 1
        -: 1014:    }
        3: 1015:    free(node);
        3: 1016:}
